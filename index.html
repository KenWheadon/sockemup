<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Sock Game</title>
    <style>
      body {
        margin: 0;
        padding: 0;
        background: #2c3e50;
        font-family: "Courier New", monospace;
        overflow: hidden;
      }
      canvas {
        display: block;
        background: #34495e;
        cursor: crosshair;
      }
      #gameContainer {
        position: relative;
        width: 100vw;
        height: 100vh;
        display: flex;
        justify-content: center;
        align-items: center;
      }
      #ui {
        position: absolute;
        top: 10px;
        left: 10px;
        color: white;
        font-size: 18px;
        z-index: 100;
      }
      #sockCounter {
        position: absolute;
        top: 10px;
        right: 10px;
        color: white;
        font-size: 18px;
        z-index: 100;
      }
    </style>
  </head>
  <body>
    <div id="gameContainer">
      <canvas id="gameCanvas"></canvas>
      <div id="ui">
        <div id="timeDisplay">Time: <span id="timeValue">60</span>s</div>
        <div id="sockBallsDisplay">
          Sock Balls: <span id="sockBallsValue">0</span>
        </div>
        <div id="pointsDisplay">Points: <span id="pointsValue">0</span></div>
      </div>
      <div id="sockCounter">
        <div id="remainingSocks">
          Remaining: <span id="remainingSocksValue">0</span>
        </div>
      </div>
    </div>

    <script>
      class SockGame {
        constructor() {
          this.canvas = document.getElementById("gameCanvas");
          this.ctx = this.canvas.getContext("2d");
          this.canvas.width = 1200;
          this.canvas.height = 800;

          this.gameState = "menu"; // menu, matching, shooting, gameOver
          this.currentLevel = 0;
          this.playerPoints = 0;
          this.playerHP = 10;
          this.sockBalls = 0;
          this.matchingTime = 60;
          this.timeRemaining = 60;

          this.images = {};
          this.loadedImages = 0;
          this.totalImages = 0;

          this.levels = [
            {
              sockTarget: 3,
              marthaSpeed: 1,
              sockPairs: 6,
              typesAvailable: [1],
              matchingTime: 60,
            },
            {
              sockTarget: 5,
              marthaSpeed: 1.5,
              sockPairs: 10,
              typesAvailable: [1, 2, 3],
              matchingTime: 45,
            },
            {
              sockTarget: 8,
              marthaSpeed: 2,
              sockPairs: 16,
              typesAvailable: [1, 2, 3, 4, 5, 6],
              matchingTime: 30,
            },
          ];

          this.unlockedLevels = [true, false, false];
          this.levelCosts = [0, 10, 25];

          // Game objects
          this.sockPile = null;
          this.socks = [];
          this.dropZones = [];
          this.sockList = [];
          this.draggedSock = null;
          this.dragOffset = { x: 0, y: 0 };
          this.crosshair = { x: 600, y: 400 };
          this.martha = null;
          this.thrownSocks = [];

          this.init();
        }

        init() {
          this.loadImages();
          this.setupEventListeners();
          this.loadGameData();
          this.gameLoop();
        }

        loadImages() {
          const imageList = [
            "sock1.png",
            "sock2.png",
            "sock3.png",
            "sock4.png",
            "sock5.png",
            "sock6.png",
            "sockpile1.png",
            "sockpile2.png",
            "sockpile3.png",
            "sockpile4.png",
            "martha.png",
            "background.png",
            "logo.png",
          ];

          this.totalImages = imageList.length;

          imageList.forEach((imageName) => {
            const img = new Image();
            img.onload = () => {
              this.loadedImages++;
              if (this.loadedImages === this.totalImages) {
                console.log("All images loaded");
              }
            };
            img.src = `images/${imageName}`;
            this.images[imageName] = img;
          });
        }

        setupEventListeners() {
          this.canvas.addEventListener("mousedown", (e) =>
            this.handleMouseDown(e)
          );
          this.canvas.addEventListener("mousemove", (e) =>
            this.handleMouseMove(e)
          );
          this.canvas.addEventListener("mouseup", (e) => this.handleMouseUp(e));
          this.canvas.addEventListener("click", (e) => this.handleClick(e));
        }

        loadGameData() {
          const savedData = localStorage.getItem("sockGameData");
          if (savedData) {
            const data = JSON.parse(savedData);
            this.playerPoints = data.playerPoints || 0;
            this.unlockedLevels = data.unlockedLevels || [true, false, false];
          }
        }

        saveGameData() {
          const data = {
            playerPoints: this.playerPoints,
            unlockedLevels: this.unlockedLevels,
          };
          localStorage.setItem("sockGameData", JSON.stringify(data));
        }

        startLevel(levelIndex) {
          this.currentLevel = levelIndex;
          const level = this.levels[levelIndex];
          this.matchingTime = level.matchingTime;
          this.timeRemaining = level.matchingTime;
          this.sockBalls = 0;
          this.playerHP = 10;

          // Generate sock list
          this.sockList = [];
          const socksPerType = Math.floor(
            (level.sockPairs * 2) / level.typesAvailable.length
          );
          level.typesAvailable.forEach((type) => {
            for (let i = 0; i < socksPerType; i++) {
              this.sockList.push(type);
            }
          });

          // Add remaining socks to reach exact pair count
          const remaining = level.sockPairs * 2 - this.sockList.length;
          for (let i = 0; i < remaining; i++) {
            this.sockList.push(
              level.typesAvailable[i % level.typesAvailable.length]
            );
          }

          // Shuffle the sock list
          for (let i = this.sockList.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [this.sockList[i], this.sockList[j]] = [
              this.sockList[j],
              this.sockList[i],
            ];
          }

          this.setupMatchingPhase();
          this.gameState = "matching";
        }

        setupMatchingPhase() {
          this.sockPile = {
            x: this.canvas.width / 2,
            y: this.canvas.height - 100,
            width: 100,
            height: 100,
            currentImage: "sockpile1.png",
          };

          this.dropZones = [
            {
              x: this.canvas.width - 150,
              y: 200,
              width: 80,
              height: 80,
              sock: null,
            },
            {
              x: this.canvas.width - 150,
              y: 320,
              width: 80,
              height: 80,
              sock: null,
            },
          ];

          this.socks = [];
          this.draggedSock = null;
        }

        updateSockPileImage() {
          const remaining = this.sockList.length;
          const total = this.levels[this.currentLevel].sockPairs * 2;
          const percentage = (remaining / total) * 100;

          if (percentage <= 0) {
            this.sockPile.currentImage = null; // Pile disappears
          } else if (percentage <= 10) {
            this.sockPile.currentImage = "sockpile4.png";
          } else if (percentage <= 30) {
            this.sockPile.currentImage = "sockpile3.png";
          } else if (percentage <= 50) {
            this.sockPile.currentImage = "sockpile2.png";
          } else {
            this.sockPile.currentImage = "sockpile1.png";
          }
        }

        handleMouseDown(e) {
          const rect = this.canvas.getBoundingClientRect();
          const x = e.clientX - rect.left;
          const y = e.clientY - rect.top;

          if (this.gameState === "matching") {
            // Check if clicking on sock pile
            if (
              this.sockPile &&
              this.sockPile.currentImage &&
              x >= this.sockPile.x - this.sockPile.width / 2 &&
              x <= this.sockPile.x + this.sockPile.width / 2 &&
              y >= this.sockPile.y - this.sockPile.height / 2 &&
              y <= this.sockPile.y + this.sockPile.height / 2
            ) {
              if (this.sockList.length > 0) {
                const sockType = this.sockList.pop();
                const newSock = {
                  id: Date.now(),
                  type: sockType,
                  x: x,
                  y: y,
                  width: 40,
                  height: 40,
                  vx: 0,
                  vy: 0,
                  bouncing: false,
                };

                this.socks.push(newSock);
                this.draggedSock = newSock;
                this.dragOffset = { x: x - newSock.x, y: y - newSock.y };
                this.updateSockPileImage();
              }
            }

            // Check if clicking on existing sock
            for (let i = this.socks.length - 1; i >= 0; i--) {
              const sock = this.socks[i];
              if (
                x >= sock.x - sock.width / 2 &&
                x <= sock.x + sock.width / 2 &&
                y >= sock.y - sock.height / 2 &&
                y <= sock.y + sock.height / 2
              ) {
                this.draggedSock = sock;
                this.dragOffset = { x: x - sock.x, y: y - sock.y };
                sock.bouncing = false;
                break;
              }
            }
          }
        }

        handleMouseMove(e) {
          const rect = this.canvas.getBoundingClientRect();
          const x = e.clientX - rect.left;
          const y = e.clientY - rect.top;

          if (this.gameState === "matching" && this.draggedSock) {
            this.draggedSock.x = x - this.dragOffset.x;
            this.draggedSock.y = y - this.dragOffset.y;
            this.draggedSock.vx = 0;
            this.draggedSock.vy = 0;
          }

          if (this.gameState === "shooting") {
            this.crosshair.x = x;
            this.crosshair.y = y;
          }
        }

        handleMouseUp(e) {
          if (this.gameState === "matching" && this.draggedSock) {
            const sock = this.draggedSock;
            let snapped = false;

            // Check for drop zone snapping
            this.dropZones.forEach((zone) => {
              const distance = Math.sqrt(
                Math.pow(sock.x - zone.x, 2) + Math.pow(sock.y - zone.y, 2)
              );

              if (distance < 60) {
                if (zone.sock === null) {
                  zone.sock = sock;
                  sock.x = zone.x;
                  sock.y = zone.y;
                  snapped = true;
                } else {
                  // Zone occupied, throw sock away
                  sock.vx = (Math.random() - 0.5) * 10;
                  sock.vy = (Math.random() - 0.5) * 10;
                  sock.bouncing = true;
                }
              }
            });

            // If not snapped, start bouncing
            if (!snapped) {
              sock.vx = (Math.random() - 0.5) * 8;
              sock.vy = (Math.random() - 0.5) * 8;
              sock.bouncing = true;
            }

            this.draggedSock = null;
            this.checkForMatch();
          }
        }

        handleClick(e) {
          const rect = this.canvas.getBoundingClientRect();
          const x = e.clientX - rect.left;
          const y = e.clientY - rect.top;

          if (this.gameState === "menu") {
            // Check level selection
            const levelSpacing = 150;
            const startX = this.canvas.width / 2 - levelSpacing;

            for (let i = 0; i < this.levels.length; i++) {
              const levelX = startX + i * levelSpacing;
              const levelY = this.canvas.height / 2 + 50;

              if (
                x >= levelX - 40 &&
                x <= levelX + 40 &&
                y >= levelY - 40 &&
                y <= levelY + 40
              ) {
                if (this.unlockedLevels[i]) {
                  this.startLevel(i);
                } else if (this.playerPoints >= this.levelCosts[i]) {
                  this.playerPoints -= this.levelCosts[i];
                  this.unlockedLevels[i] = true;
                  this.saveGameData();
                  this.startLevel(i);
                }
                break;
              }
            }
          }

          if (this.gameState === "shooting") {
            this.fireSock();
          }

          if (this.gameState === "gameOver") {
            this.gameState = "menu";
          }
        }

        checkForMatch() {
          if (this.dropZones[0].sock && this.dropZones[1].sock) {
            if (this.dropZones[0].sock.type === this.dropZones[1].sock.type) {
              // Match found!
              this.sockBalls++;

              // Remove matched socks
              this.socks = this.socks.filter(
                (sock) =>
                  sock !== this.dropZones[0].sock &&
                  sock !== this.dropZones[1].sock
              );

              // Clear drop zones
              this.dropZones[0].sock = null;
              this.dropZones[1].sock = null;

              // Check if matching phase is complete
              if (
                this.sockList.length === 0 &&
                this.sockBalls >= this.levels[this.currentLevel].sockPairs
              ) {
                this.startShootingPhase();
              }
            }
          }
        }

        startShootingPhase() {
          this.gameState = "shooting";
          this.martha = {
            x: this.canvas.width + 50,
            y: this.canvas.height / 2,
            width: 60,
            height: 80,
            vx: -this.levels[this.currentLevel].marthaSpeed,
            direction: -1,
            hitEffect: 0,
          };

          this.thrownSocks = [];
        }

        fireSock() {
          if (this.sockBalls > 0) {
            const angle = Math.atan2(
              this.martha.y - this.crosshair.y,
              this.martha.x - this.crosshair.x
            );
            const speed = 8;

            this.thrownSocks.push({
              x: this.crosshair.x,
              y: this.crosshair.y,
              vx: Math.cos(angle) * speed,
              vy: Math.sin(angle) * speed,
              type: 1, // Could be random from available types
            });

            this.sockBalls--;
          }
        }

        update() {
          if (this.gameState === "matching") {
            this.updateMatching();
          } else if (this.gameState === "shooting") {
            this.updateShooting();
          }
        }

        updateMatching() {
          this.timeRemaining -= 1 / 60;

          if (this.timeRemaining <= 0) {
            this.startShootingPhase();
          }

          // Update bouncing socks
          this.socks.forEach((sock) => {
            if (sock.bouncing) {
              sock.x += sock.vx;
              sock.y += sock.vy;

              // Bounce off walls
              if (
                sock.x <= sock.width / 2 ||
                sock.x >= this.canvas.width - sock.width / 2
              ) {
                sock.vx *= -0.8;
              }
              if (
                sock.y <= sock.height / 2 ||
                sock.y >= this.canvas.height - sock.height / 2
              ) {
                sock.vy *= -0.8;
              }

              // Keep socks in bounds
              sock.x = Math.max(
                sock.width / 2,
                Math.min(this.canvas.width - sock.width / 2, sock.x)
              );
              sock.y = Math.max(
                sock.height / 2,
                Math.min(this.canvas.height - sock.height / 2, sock.y)
              );

              // Apply friction
              sock.vx *= 0.98;
              sock.vy *= 0.98;

              // Stop bouncing if velocity is low
              if (Math.abs(sock.vx) < 0.1 && Math.abs(sock.vy) < 0.1) {
                sock.bouncing = false;
              }
            }
          });
        }

        updateShooting() {
          // Update Martha
          this.martha.x += this.martha.vx;

          // Martha movement pattern
          if (this.martha.x <= 50) {
            this.martha.vx = this.levels[this.currentLevel].marthaSpeed;
            this.martha.direction = 1;
          } else if (this.martha.x >= this.canvas.width - 50) {
            this.martha.vx = -this.levels[this.currentLevel].marthaSpeed;
            this.martha.direction = -1;
          }

          // Update hit effect
          if (this.martha.hitEffect > 0) {
            this.martha.hitEffect--;
          }

          // Update thrown socks
          this.thrownSocks.forEach((sock, index) => {
            sock.x += sock.vx;
            sock.y += sock.vy;
            sock.vy += 0.2; // Gravity

            // Check collision with Martha
            if (
              sock.x >= this.martha.x - this.martha.width / 2 &&
              sock.x <= this.martha.x + this.martha.width / 2 &&
              sock.y >= this.martha.y - this.martha.height / 2 &&
              sock.y <= this.martha.y + this.martha.height / 2
            ) {
              this.martha.hitEffect = 60; // 1 second at 60fps
              this.thrownSocks.splice(index, 1);

              // Check if level complete
              if (this.sockBalls === 0 && this.thrownSocks.length === 0) {
                this.endLevel();
              }
            }

            // Remove socks that go off screen
            if (sock.y > this.canvas.height + 50) {
              this.thrownSocks.splice(index, 1);
              this.playerHP--;

              if (this.playerHP <= 0) {
                this.gameState = "gameOver";
              }
            }
          });

          // End level if no more socks
          if (this.sockBalls === 0 && this.thrownSocks.length === 0) {
            this.endLevel();
          }
        }

        endLevel() {
          // Calculate score
          const remainingSocks = this.sockBalls;
          const points = remainingSocks * 10;
          this.playerPoints += points;

          this.saveGameData();
          this.gameState = "gameOver";
        }

        render() {
          this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

          // Draw background
          if (this.images["background.png"]) {
            this.ctx.drawImage(
              this.images["background.png"],
              0,
              0,
              this.canvas.width,
              this.canvas.height
            );
          }

          if (this.gameState === "menu") {
            this.renderMenu();
          } else if (this.gameState === "matching") {
            this.renderMatching();
          } else if (this.gameState === "shooting") {
            this.renderShooting();
          } else if (this.gameState === "gameOver") {
            this.renderGameOver();
          }

          this.updateUI();
        }

        renderMenu() {
          // Draw logo
          if (this.images["logo.png"]) {
            this.ctx.drawImage(
              this.images["logo.png"],
              this.canvas.width / 2 - 100,
              100,
              200,
              100
            );
          }

          // Draw level selection
          this.ctx.fillStyle = "white";
          this.ctx.font = "24px Courier New";
          this.ctx.textAlign = "center";
          this.ctx.fillText(
            "Select Level",
            this.canvas.width / 2,
            this.canvas.height / 2 - 50
          );

          const levelSpacing = 150;
          const startX = this.canvas.width / 2 - levelSpacing;

          for (let i = 0; i < this.levels.length; i++) {
            const levelX = startX + i * levelSpacing;
            const levelY = this.canvas.height / 2 + 50;

            if (this.unlockedLevels[i]) {
              // Draw unlocked level as animated sock
              const wiggle = Math.sin(Date.now() * 0.01 + i) * 3;
              if (this.images["sock1.png"]) {
                this.ctx.drawImage(
                  this.images["sock1.png"],
                  levelX - 40 + wiggle,
                  levelY - 40,
                  80,
                  80
                );
              }

              this.ctx.fillStyle = "white";
              this.ctx.font = "16px Courier New";
              this.ctx.fillText(`Level ${i + 1}`, levelX, levelY + 60);
            } else {
              // Draw locked level
              this.ctx.fillStyle = "gray";
              this.ctx.fillRect(levelX - 40, levelY - 40, 80, 80);

              this.ctx.fillStyle = "white";
              this.ctx.font = "16px Courier New";
              this.ctx.fillText(
                `Cost: ${this.levelCosts[i]}`,
                levelX,
                levelY - 50
              );
              this.ctx.fillText(`Level ${i + 1}`, levelX, levelY + 60);
            }
          }

          // Show current points
          this.ctx.fillStyle = "yellow";
          this.ctx.font = "20px Courier New";
          this.ctx.fillText(
            `Points: ${this.playerPoints}`,
            this.canvas.width / 2,
            this.canvas.height - 50
          );
        }

        renderMatching() {
          // Draw sock pile
          if (
            this.sockPile.currentImage &&
            this.images[this.sockPile.currentImage]
          ) {
            this.ctx.drawImage(
              this.images[this.sockPile.currentImage],
              this.sockPile.x - this.sockPile.width / 2,
              this.sockPile.y - this.sockPile.height / 2,
              this.sockPile.width,
              this.sockPile.height
            );
          }

          // Draw drop zones
          this.dropZones.forEach((zone) => {
            this.ctx.strokeStyle = "white";
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(
              zone.x - zone.width / 2,
              zone.y - zone.height / 2,
              zone.width,
              zone.height
            );
          });

          // Draw socks
          this.socks.forEach((sock) => {
            if (this.images[`sock${sock.type}.png`]) {
              this.ctx.drawImage(
                this.images[`sock${sock.type}.png`],
                sock.x - sock.width / 2,
                sock.y - sock.height / 2,
                sock.width,
                sock.height
              );
            }
          });

          // Draw sock balls counter
          this.ctx.fillStyle = "white";
          this.ctx.font = "18px Courier New";
          this.ctx.textAlign = "left";
          this.ctx.fillText(
            `Sock Balls: ${this.sockBalls}`,
            this.canvas.width - 200,
            150
          );
        }

        renderShooting() {
          // Draw Martha
          if (this.images["martha.png"]) {
            this.ctx.save();
            if (this.martha.hitEffect > 0) {
              this.ctx.globalAlpha = 0.5;
              this.ctx.filter = "brightness(200%)";
            }
            this.ctx.drawImage(
              this.images["martha.png"],
              this.martha.x - this.martha.width / 2,
              this.martha.y - this.martha.height / 2,
              this.martha.width,
              this.martha.height
            );
            this.ctx.restore();
          }

          // Draw crosshair
          this.ctx.strokeStyle = "red";
          this.ctx.lineWidth = 2;
          this.ctx.beginPath();
          this.ctx.moveTo(this.crosshair.x - 10, this.crosshair.y);
          this.ctx.lineTo(this.crosshair.x + 10, this.crosshair.y);
          this.ctx.moveTo(this.crosshair.x, this.crosshair.y - 10);
          this.ctx.lineTo(this.crosshair.x, this.crosshair.y + 10);
          this.ctx.stroke();

          // Draw thrown socks
          this.thrownSocks.forEach((sock) => {
            if (this.images[`sock${sock.type}.png`]) {
              this.ctx.drawImage(
                this.images[`sock${sock.type}.png`],
                sock.x - 20,
                sock.y - 20,
                40,
                40
              );
            }
          });

          // Draw Martha's dialogue
          this.ctx.fillStyle = "white";
          this.ctx.font = "16px Courier New";
          this.ctx.textAlign = "center";
          this.ctx.fillText(
            `I DEMAND ${
              this.levels[this.currentLevel].sockTarget
            } PAIRS OF SOCKS OR ELSE!`,
            this.canvas.width / 2,
            50
          );

          // Draw HP
          this.ctx.fillStyle = "red";
          this.ctx.font = "18px Courier New";
          this.ctx.textAlign = "left";
          this.ctx.fillText(`HP: ${this.playerHP}`, 10, 30);
        }

        renderGameOver() {
          this.ctx.fillStyle = "white";
          this.ctx.font = "32px Courier New";
          this.ctx.textAlign = "center";
          this.ctx.fillText(
            "Level Complete!",
            this.canvas.width / 2,
            this.canvas.height / 2 - 50
          );

          this.ctx.font = "18px Courier New";
          this.ctx.fillText(
            `Points Earned: ${this.sockBalls * 10}`,
            this.canvas.width / 2,
            this.canvas.height / 2
          );
          this.ctx.fillText(
            `Total Points: ${this.playerPoints}`,
            this.canvas.width / 2,
            this.canvas.height / 2 + 30
          );
          this.ctx.fillText(
            "Click to continue",
            this.canvas.width / 2,
            this.canvas.height / 2 + 80
          );
        }

        updateUI() {
          document.getElementById("timeValue").textContent = Math.max(
            0,
            Math.floor(this.timeRemaining)
          );
          document.getElementById("sockBallsValue").textContent =
            this.sockBalls;
          document.getElementById("pointsValue").textContent =
            this.playerPoints;
          document.getElementById("remainingSocksValue").textContent =
            this.sockList.length;
        }

        gameLoop() {
          this.update();
          this.render();
          requestAnimationFrame(() => this.gameLoop());
        }
      }

      // Start the game
      const game = new SockGame();
    </script>
  </body>
</html>
